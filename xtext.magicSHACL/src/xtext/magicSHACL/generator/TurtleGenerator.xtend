/*
 * generated by Xtext 2.24.0
 */
package xtext.magicSHACL.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import magicSHACL.ShapeConstraint
import magicSHACL.PropertyValues
import magicSHACL.PropertyType
import java.util.List
import magicSHACL.ShapeExpression
import magicSHACL.Property
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtleGenerator extends AbstractGenerator {
	
	List<String> shapes;
	int shapesCounter;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		shapes = new ArrayList();
		shapesCounter = 0;
		fsa.generateFile(resource.URI.lastSegment.replace(".ttl", ".simple"), '''
            «FOR constraint : resource.allContents.filter(ShapeConstraint).toIterable SEPARATOR ';\n' AFTER ';\n'»«
            	constraint.shapeName.name» :- «
                FOR exp : constraint.shapeExpressions.filter[e | !e.propertyValues.filter[pv | isPropertyOrPath(pv.property.type)].empty].toList SEPARATOR ' AND '
                	»«normalize(exp)»«
                ENDFOR»«
             ENDFOR»«
             FOR shape : shapes SEPARATOR ';\n' AFTER ';'»«
             	shape»«
             ENDFOR»
        ''')
	}
	
	private def normalize(ShapeExpression exp){
		val simplify = simplifyExpression(exp)
		val s = exp.type == PropertyType.NOT_CONSTRAINT_COMPONENT ? 'NOT ' :'';
		
		if (isComplex(simplify) && exp.propertyValues.size > 1){
			shapesCounter++;
			shapes.add('S' + shapesCounter + ' :- ' + simplify);
			return s + 'S' + shapesCounter;
		}else{
			return s + simplify;
		}
	}
	
	private def isComplex(String expression){
		if(expression.contains('MAX') ||
			expression.contains('MIN') ||
			expression.contains('SOME'))
			return true;
		return false;
	}
	
	private def isPropertyOrPath(PropertyType type){
		return (
				type == PropertyType.PROPERTY || 
				type == PropertyType.PREDICATE_PATH || 
				type == PropertyType.INVERSE_PATH
		);
	}
	
	private def simplifyExpression(ShapeExpression expression) {
		val maxCount = getValues(expression, PropertyType.MAX_COUNT_CONSTRAINT_COMPONENT)
		val minCount = getValues(expression, PropertyType.MIN_COUNT_CONSTRAINT_COMPONENT)
		val class = getValues(expression, PropertyType.CLASS_CONSTRAINT_COMPONENT)
		val property = getValues(expression, PropertyType.PROPERTY)
				
		if(maxCount !== null)
			return 'MAX ' + maxCount.values.get(0).name + ' ' + getPath(expression) + ' ' 
				+ ((class!==null) ? class.values.get(0).name : 'ADom');
		if(minCount !== null)
			return 'MIN ' + minCount.values.get(0).name + ' ' + getPath(expression) + ' ' 
				+ ((class!==null) ? class.values.get(0).name : 'ADom');
		if(class !== null)
			return 'SOME ' + getPath(expression) + ' ' + class.values.get(0).name ;
		if(property !== null && expression.propertyValues.size == 1)
			return property.values.get(0).name;	
		return 'SOME ' + getPath(expression) + ' ADom';
	}
	
	private def getValues(ShapeExpression expression, PropertyType type) {
		val values = expression.eAllContents.filter(magicSHACL.PropertyValues).toList.findFirst[property.type == type];	
					
		if (values !== null) {
			return values;	
		} else {
			return expression.eContainer.eAllContents.filter(magicSHACL.PropertyValues).toList.findFirst[property.type == type];
		}		
	}
	
	private def getPath(ShapeExpression expression) {
		val path = expression.eAllContents.filter(magicSHACL.PropertyValues).toList.findFirst[property.type == PropertyType.PREDICATE_PATH || 
					property.type == PropertyType.INVERSE_PATH];
					
		if (path !== null) {
			return (path.property.type == PropertyType.INVERSE_PATH ? '^' : '') + path.values.get(0).name;	
		} else {
			return (path.property.type == PropertyType.INVERSE_PATH ? '^' : '') + 
					expression.eContainer.eAllContents.filter(magicSHACL.PropertyValues).toList.findFirst[
						property.type == PropertyType.PREDICATE_PATH || 
						property.type == PropertyType.INVERSE_PATH].values.get(0).name;
		}	
	}
}
