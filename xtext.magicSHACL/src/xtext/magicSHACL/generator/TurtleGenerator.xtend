/*
 * generated by Xtext 2.24.0
 */
package xtext.magicSHACL.generator

import magicSHACL.PropertyType
import magicSHACL.ShapeConstraint
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import magicSHACL.ShapeExpression
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtleGenerator extends AbstractGenerator {
	int i;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile(resource.URI.lastSegment.replace(".ttl", ".simple"), '''
            «FOR constraint : resource.allContents.filter(ShapeConstraint).toIterable»«
            	val shapes = shapeExpressionToAbstractString(constraint.shapeExpressions)»«
            	constraint.shapeName.name» :- «
            	IF shapes.size == 1»«
            		shapes.get(0)» ;  
 				«ELSE»
 					«(i = 0)==true?'':''»«
 					FOR shape : shapes SEPARATOR ' AND ' AFTER ';\n'»«
            			constraint.shapeName.name»_S«shapes.indexOf(shape)»«
            		ENDFOR»«
            		(i = 0)==true?'':''»«
            		FOR shape : shapes SEPARATOR ';\n' AFTER ';\n'»
            			«constraint.shapeName.name»_S«shapes.indexOf(shape)» :- «shape»«
            		ENDFOR»	
            	«ENDIF»«
             ENDFOR»
        ''')
	}
	
	def shapeExpressionToAbstractString(List<ShapeExpression> shapeExpressions){
		val normalized = newArrayList
	 	
		val path = getValuesOfProperty(shapeExpressions, PropertyType.PREDICATE_PATH)
		val inversePath = getValuesOfProperty(shapeExpressions, PropertyType.INVERSE_PATH)
		val maxCount = getValuesOfProperty(shapeExpressions, PropertyType.MAX_COUNT_CONSTRAINT_COMPONENT)
		val minCount = getValuesOfProperty(shapeExpressions, PropertyType.MIN_COUNT_CONSTRAINT_COMPONENT)
		val class = getValuesOfProperty(shapeExpressions, PropertyType.CLASS_CONSTRAINT_COMPONENT)
		val node = getValuesOfProperty(shapeExpressions, PropertyType.NODE_CONSTRAINT_COMPONENT)
		
		var object = 'ADom'
		if (class.size > 0 )
			object = class.get(0).toString
		else if (node.size > 0 )
			object = node.get(0).toString
		
		if(maxCount.size > 0)
			normalized.add('MAX ' + maxCount.get(0) + ' ' + path.get(0) + ' ' + object)
		if(minCount.size > 0)
			normalized.add('MIN ' + minCount.get(0) + ' ' + path.get(0) + ' ' + object)
		if(maxCount.size == 0 && minCount.size == 0 && path.size > 0)
			normalized.add('SOME ' + path.get(0) + ' ' + object)
		if(inversePath.size > 0)
			normalized.add('^' + inversePath.get(0)) 
		
		for(value : getValuesOfProperty(shapeExpressions, PropertyType.OR_CONSTRAINT_COMPONENT))
			normalized.add(value)
		for(value : getValuesOfProperty(shapeExpressions, PropertyType.PROPERTY))
			normalized.add(value)
		val notValues = getValuesOfProperty(shapeExpressions, PropertyType.NOT_CONSTRAINT_COMPONENT)
		for(value : notValues){
			val newShapeName = (shapeExpressions.get(0).eContainer as ShapeConstraint).shapeName.name + '_S' + normalized.size
			normalized.add('NOT ' + newShapeName + ';\n' + newShapeName + ' :- ' + value)
		}
		for(value : getValuesOfProperty(shapeExpressions, PropertyType.AND_CONSTRAINT_COMPONENT))
			normalized.add(value)
		
		return normalized
	}
	
	def getValuesOfProperty(List<ShapeExpression> shapeExpressions, PropertyType type){
		val expressions = shapeExpressions.filter[e | e.type == type].toList 
		var values = newArrayList
		
		var properties = ''
		for(expression : expressions){
			if(expression.shapeExpressions.size > 0)
				values.addAll(shapeExpressionToAbstractString(expression.shapeExpressions))
			if (type == PropertyType.OR_CONSTRAINT_COMPONENT){
				var s = ''
				for(subexp : expression.shapeExpressions)
					if(!subexp.abstractString.blank)
						s += 'OR ' + subexp.abstractString
				if(s.length > 4)
						values.add(s.substring(3))
			} 
			if (expression.values.size > 0)
				properties += ' AND ' + expression.values.get(0).name
		}
		
		if(properties.length > 0)
			values.add(properties.substring(5))
		return values
	}
}
